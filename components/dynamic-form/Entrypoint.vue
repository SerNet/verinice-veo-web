<!--
   - verinice.veo web
   - Copyright (C) 2022  Jonas Heitmann
   -
   - This program is free software: you can redistribute it and/or modify
   - it under the terms of the GNU Affero General Public License as published by
   - the Free Software Foundation, either version 3 of the License, or
   - (at your option) any later version.
   -
   - This program is distributed in the hope that it will be useful,
   - but WITHOUT ANY WARRANTY; without even the implied warranty of
   - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   - GNU Affero General Public License for more details.
   -
   - You should have received a copy of the GNU Affero General Public License
   - along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<script lang="ts">
import { ComputedRef, PropType } from 'vue';
import { cloneDeep, debounce, merge, take, takeRight } from 'lodash';
import { JsonPointer } from 'json-ptr';
import { JSONSchema7 } from 'json-schema';
import { ErrorObject } from 'ajv';

import {
  IVeoFormsAdditionalContext,
  IVeoFormsReactiveFormActions,
  IVeoFormsTranslations,
  IVeoFormElementFormSchema,
  IVeoFormControlFormSchema,
  IVeoFormLabelFormSchema,
  IVeoFormWidgetFormSchema
} from './types';
import {
  evaluateRule,
  removePropertiesKeywordFromPath,
  addConditionalSchemaPropertiesToControlSchema,
  ajv,
  generateFormSchema,
  generateFormSchemaControl,
  generateFormSchemaGroup,
  Mode
} from './util';
import Control from './controls/Control';
import Widget from './widgets/Widget';
import Group from './layouts/Group.vue';
import Label from './labels/Label.vue';
import ValidationFailedError from './ValidationFailedError.vue';
import { IVeoFormSchemaGeneratorOptions, IVeoObjectSchema } from '~/types/VeoTypes';
import FormSchemaValidator from '~/lib/FormSchemaValidator';
import { VeoSchemaValidatorValidationResult } from '~/lib/ObjectSchemaValidator';
import { useVeoReactiveFormActions } from '~/composables/VeoReactiveFormActions';
import { useVeoErrorFormatter } from '~/composables/VeoErrorFormatter';
import { IVeoFormSchemaItem } from '~/composables/api/queryDefinitions/forms';

const DEBUG_MAP = new Map<string, string>();
// @ts-ignore We add a new property to the window to debug veo forms
window.VEO_FORMS_DEBUG_MAP = DEBUG_MAP;

const GENERATOR_OPTIONS = (props: any) =>
  ({
    excludedProperties: [
      '/id$',
      '/type$',
      '/owner$',
      '^#/properties/links',
      '/updatedAt$',
      '/updatedBy$',
      '/createdAt$',
      '/createdBy$',
      '/parts$',
      '/members$',
      '/risks$',
      '/designator$',
      '/decisionResults',
      '(\\w+)/properties/domains$',
      '_self'
    ],
    groupedNamespaces: Object.keys(props.objectSchema.properties?.customAspects?.properties || {}).map((key) => ({
      namespace: `#/properties/customAspects/properties/${key}`,
      label: key
    })),
    generateControlFunction: generateFormSchemaControl,
    generateGroupFunction: generateFormSchemaGroup
  }) as IVeoFormSchemaGeneratorOptions;

export default defineComponent({
  props: {
    /**
     * The value of the form
     */
    modelValue: {
      type: Object as PropType<Record<string, any>>,
      default: () => ({})
    },
    locale: {
      type: String,
      default: undefined
    },
    /**
     * The object schema. Required. Creates the requiresd inputs.
     */
    objectSchema: {
      type: Object as PropType<IVeoObjectSchema>,
      required: true
    },
    /**
     * The form schema. Rearranges the inputs generated by the object schema and adds additional labels.
     */
    formSchema: {
      type: Object as PropType<IVeoFormSchemaItem>,
      default: undefined
    },
    /**
     * Meta data belonging to the form/object. Gets passed down for use by controls, layouts and widgets.
     */
    metaData: {
      type: Object as PropType<Record<string, any>>,
      default: undefined
    },
    /**
     * Modifies the form and/or object schema at runtime.
     */
    additionalContext: {
      type: Object as PropType<IVeoFormsAdditionalContext>,
      default: undefined
    },
    /**
     * Get called after a value changes to update other data based on the changed data.
     */
    reactiveFormActions: {
      type: Object as PropType<IVeoFormsReactiveFormActions>,
      default: undefined
    },
    /**
     * Disables the complete form. If you only want to disable certain inputs, use the additional context.
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Disables creating new objects using the VeoCreateObjectDialog from within the form. Usually only set to true to avoid stacking VeoCreateObjectDialogs.
     */
    objectCreationDisabled: {
      type: Boolean,
      default: false
    },
    /**
     * Translations. VeoForms searches for all labels starting with #lang/... in this map.
     */
    translations: {
      type: Object as PropType<IVeoFormsTranslations>,
      default: () => ({})
    },
    /**
     * If set to true, VeoForms will print a variety of data to the console in order to debug VeoForms.
     */
    debug: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:model-value', 'update:messages', 'update:valid'],
  setup(props, { emit }) {
    const { locale } = useI18n();

    const { defaultReactiveFormActions } = useVeoReactiveFormActions();
    const { formatErrors } = useVeoErrorFormatter();

    const localTranslations = computed(() => props.translations?.[props.locale || locale.value] || {});
    const localAdditionalContext = computed(() => props.additionalContext || {});
    const localObjectSchema = computed(() => props.objectSchema);
    const localFormSchema = computed(
      () =>
        cloneDeep(props.formSchema) || generateFormSchema(localObjectSchema.value, GENERATOR_OPTIONS(props), Mode.VEO)
    );
    const localReactiveFormActions = computed(() => {
      const toReturn = defaultReactiveFormActions();
      if (props.reactiveFormActions !== undefined) {
        for (const key in props.reactiveFormActions || {}) {
          if (toReturn[key]) {
            toReturn[key].push(...props.reactiveFormActions[key]);
          } else {
            toReturn[key] = props.reactiveFormActions[key];
          }
        }
      }
      return toReturn;
    });

    // Form schema validation
    const formSchemaValidator = new FormSchemaValidator();
    const formSchemaFitsObjectSchema = computed<VeoSchemaValidatorValidationResult>(() =>
      formSchemaValidator.validate(localFormSchema.value, localObjectSchema.value)
    );

    // Object data validation
    const errorMessages = ref(new Map<string, string[]>());
    const validateFunction = computed(() => ajv.compile(localObjectSchema.value));

    // global available data
    const _value = computed(() => props.modelValue);
    provide('translations', localTranslations);
    provide('objectData', _value);

    // Form generation
    const defaultProps = computed(() => ({
      metaData: props.metaData,
      disabled: props.disabled,
      objectCreationDisabled: props.objectCreationDisabled,
      debug: props.debug
    }));

    const createComponent = (
      element: any,
      formSchemaPointer: string,
      translations: Record<string, any>,
      localObjectSchema: ComputedRef<IVeoObjectSchema>
    ): any => {
      const rule = evaluateRule(_value.value, element.rule);

      const options = merge(cloneDeep(element.options || {}), rule);
      // Turn text of label into options.label field to enable translations
      if (element.type === 'Label' && element.text) {
        options.label = element.text;
      }
      if (options.label && options.label.startsWith('#lang/')) {
        const key = options.label.split('/')[1];
        options.label = translations[key] || key;

        // Add an asterix to required fields
        const parentPointer = (element.scope || '').split('/');
        const elementId = parentPointer.pop();
        parentPointer.pop();
        const requiredElements =
          (JsonPointer.get(props.objectSchema, `${parentPointer.join('/')}/required`) as string[]) || [];
        if (requiredElements.includes(elementId)) {
          options.label = `${options.label}*`;
        }
      }

      if (options.visible) {
        switch (element.type) {
          case 'Layout':
            return createLayout({ ...element, options }, formSchemaPointer, translations, localObjectSchema);
          case 'Control':
            return createControl({ ...element, options }, formSchemaPointer, translations, localObjectSchema);
          case 'Label':
            return createLabel({ ...element, options }, formSchemaPointer);
          case 'Widget':
            return createWidget({ ...element, options }, formSchemaPointer);
        }
      } else {
        // VeoForms is confused if a form element doesn't exist and then suddently gets added as a new node, so we insert a placeholder element if the form element should be hidden
        return h('template');
      }
    };

    const createChildren = (
      element: IVeoFormElementFormSchema,
      formSchemaPointer: string,
      translations: Record<string, any>,
      localObjectSchema: ComputedRef<IVeoObjectSchema>
    ) => {
      if (!element.elements || !element.elements.length) {
        return undefined;
      }
      return (
        element.elements &&
        element.elements.map((elem, index) =>
          createComponent(elem, `${formSchemaPointer}/elements/${index}`, translations, localObjectSchema)
        )
      );
    };

    const createLayout = (
      element: IVeoFormElementFormSchema,
      formSchemaPointer: string,
      translations: Record<string, any>,
      localObjectSchema: ComputedRef<IVeoObjectSchema>
    ) => {
      return h(
        Group,
        {
          ...defaultProps.value,
          options: element.options,
          formSchemaPointer
        },
        {
          default: () => createChildren(element, formSchemaPointer, translations, localObjectSchema)
        }
      );
    };

    const createLabel = (element: IVeoFormLabelFormSchema, formSchemaPointer: string) => {
      return h(Label, {
        key: formSchemaPointer,
        ...defaultProps.value,
        options: element.options,
        formSchemaPointer
      });
    };

    const createWidget = (element: IVeoFormWidgetFormSchema, formSchemaPointer: string) => {
      return h(Widget, {
        ...defaultProps.value,
        options: element.options,
        formSchemaPointer,
        name: element.name
      });
    };

    const createControl = (
      element: IVeoFormControlFormSchema,
      formSchemaPointer: string,
      translations: Record<string, any>,
      localObjectSchema: ComputedRef<IVeoObjectSchema>
    ) => {
      let scope = cloneDeep(element.scope);
      if (!scope) {
        if (process.dev && props.debug) {
          // eslint-disable-next-line no-console
          console.warn(`VeoForm::createControl: Control ${formSchemaPointer} has no scope: ${JSON.stringify(element)}`);
        }
        return;
      }

      // Special handling for link attributes, as they don't have a complete pointer in the form schema as they can only exist inside of their link
      if (scope.startsWith('#/properties/attributes')) {
        if (process.dev && props.debug) {
          // eslint-disable-next-line no-console
          console.warn(
            `VeoForm::createControl: Custom Link attribute detected: ${scope}. Searching for custom link...`
          );
        }
        // Get object schema pointer of link based on the assumption that link attributes can't get displayed separately from the link
        const formSchemaPointerFragments = formSchemaPointer.split('/');
        const parentFormSchemaPointer = take(formSchemaPointerFragments, formSchemaPointerFragments.length - 2).join(
          '/'
        ); // Links can't be deconstructed, so the attributes are always direct children of the link
        const parentObjectSchemaPointer = (
          JsonPointer.get(localFormSchema.value, parentFormSchemaPointer) as IVeoFormControlFormSchema
        ).scope;

        // Glue the object schema pointer of the link attribute to the one of the link to create a valid one for the whole object
        const objectSchemaPointerFragments = scope.split('/');
        scope =
          parentObjectSchemaPointer +
          '/items/' +
          takeRight(objectSchemaPointerFragments, objectSchemaPointerFragments.length - 1).join('/');
      }

      const controlObjectSchema = computed(() => ({
        ...(JsonPointer.get(localObjectSchema.value, scope) as JSONSchema7),
        ...(localAdditionalContext.value[scope]?.objectSchema || {})
      }));
      const valuePointer = computed(() => removePropertiesKeywordFromPath(scope));
      return h(
        Control,
        {
          elementKey: scope,
          ...defaultProps.value,
          options: {
            ...element.options,
            ...localAdditionalContext.value[scope]?.formSchema
          },
          formSchemaPointer,
          objectSchemaPointer: scope,
          objectSchema: addConditionalSchemaPropertiesToControlSchema(
            localObjectSchema.value,
            _value.value,
            controlObjectSchema.value,
            scope
          ),
          valuePointer: valuePointer.value,
          modelValue: JsonPointer.get(_value.value, valuePointer.value),
          errors: errorMessages.value,
          'onUpdate:modelValue': onUpdate
        },
        {
          default: () => createChildren(element, formSchemaPointer, translations, localObjectSchema)
        }
      );
    };

    // Input handling
    const formError = ref<string | undefined>();
    const validateFormData = (data: Record<string, any>) => {
      // Validate new form data
      /**
       * Why try/catch?
       * Usually the validateFunction should return true/false and if it returns false, validateFunction.errors should be set, however in some cases the
       * validate function throws an error with a single string as the cause. In this case the form crashes. To avoid this,
       * next to formatting the error messages, we wrap the validateFunction in a try/catch and if it throws an error,
       * we expect a serious problem to have occurred (usually within the object schema parsing) and display a
       * prominent error message instead of the form as this problem isn't user-fixable
       */
      try {
        const formIsValid = validateFunction.value(data);
        if (!formIsValid) {
          errorMessages.value = formatErrors(validateFunction.value.errors as ErrorObject[], localTranslations.value);
        } else {
          errorMessages.value = new Map();
        }
        emit('update:messages', errorMessages.value);
        emit('update:valid', formIsValid);
      } catch (e: any) {
        formError.value = e.message;
      }
    };

    /**
     * UPDATE DYNMIC-FORMS:
     */
    let formData: Record<string, any>;

    function updateForm() {
      emit('update:model-value', formData);
    }

    const updateFormDebounced = debounce(updateForm, 250);

    // Every input uses this fn to store its state in `updateFormData`
    function onUpdate(objectSchemaPointer: string, newValue: any, oldValue: string, index?: number) {
      updateFormData({ objectSchemaPointer, newValue, oldValue, index });
      updateFormDebounced();
    }

    type updateFormDataParams = {
      objectSchemaPointer: string;
      newValue: any;
      oldValue: string;
      index?: number;
    };

    function updateFormData({ objectSchemaPointer, newValue, oldValue, index }: updateFormDataParams) {
      let valuePointer = removePropertiesKeywordFromPath(objectSchemaPointer);

      // If this condition is truthy, we have a link attribute and have to replace /items/ with the index.
      if (index !== undefined && valuePointer.includes('/items/')) {
        valuePointer = valuePointer.replace('/items/', `/${index}/`);
      }

      // '' should be handled as if the value was deleted (an empty input field cleared with backspace returns '', while an input field cleared with the clear button returns undefined)
      if (newValue === '' || newValue === null) {
        newValue = undefined;
      }

      // Set new value
      if (newValue === undefined) {
        JsonPointer.unset(formData, valuePointer);
      } else {
        JsonPointer.set(formData, valuePointer, newValue, true);
      }

      // Apply reactive form actions
      for (const action of localReactiveFormActions.value[objectSchemaPointer] || []) {
        formData = action(newValue, oldValue, formData, _value.value);
      }
    }

    watch(
      () => props.modelValue,
      (newValue) => {
        formData = cloneDeep(props.modelValue);
        validateFormData(newValue);
      },
      { immediate: true }
    );

    return () =>
      !formSchemaFitsObjectSchema.value?.valid || !!formError.value ?
        h(ValidationFailedError, {
          errors: [
            ...(formSchemaFitsObjectSchema.value?.errors || []),
            ...(formError.value ? [{ code: 'OS_Error', message: formError.value }] : [])
          ]
        })
      : h('div', { class: 'vf-wrapper' }, [
          createComponent(localFormSchema.value, '#', localTranslations.value, localObjectSchema)
        ]);
  }
});
</script>
