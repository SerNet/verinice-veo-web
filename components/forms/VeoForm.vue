<!--
   - verinice.veo web
   - Copyright (C) 2022  Jonas Heitmann
   - 
   - This program is free software: you can redistribute it and/or modify
   - it under the terms of the GNU Affero General Public License as published by
   - the Free Software Foundation, either version 3 of the License, or
   - (at your option) any later version.
   - 
   - This program is distributed in the hope that it will be useful,
   - but WITHOUT ANY WARRANTY; without even the implied warranty of
   - MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   - GNU Affero General Public License for more details.
   - 
   - You should have received a copy of the GNU Affero General Public License
   - along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->
<script lang="ts">
import { computed, defineComponent, h, PropType, ref } from '@nuxtjs/composition-api';
import { useI18n } from 'nuxt-i18n-composable';
import { cloneDeep, merge, take, takeRight } from 'lodash';
import { JsonPointer } from 'json-ptr';
import { JSONSchema7 } from 'json-schema';
import { ErrorObject } from 'ajv';

import {
  IVeoFormsAdditionalContext,
  IVeoFormsReactiveFormActions,
  IVeoFormsTranslations,
  IVeoFormElementFormSchema,
  IVeoFormControlFormSchema,
  IVeoFormLabelFormSchema,
  IVeoFormWidgetFormSchema,
  IVeoFormElementDefaultProps
} from './types';
import {
  evaluateRule,
  removePropertiesKeywordFromPath,
  addConditionalSchemaPropertiesToControlSchema,
  ajv,
  generateFormSchema,
  generateFormSchemaControl,
  generateFormSchemaGroup,
  Mode
} from './util';
import Control from './controls/Control';
import Widget from './widgets/Widget';
import VeoGroup from './layouts/VeoGroup.vue';
import VeoLabel from './labels/VeoLabel.vue';
import VeoValidationResultList from '~/components/util/VeoValidationResultList.vue';
import { IBaseObject } from '~/lib/utils';
import { IVeoFormSchema, IVeoFormSchemaGeneratorOptions, IVeoObjectSchema } from '~/types/VeoTypes';
import FormSchemaValidator from '~/lib/FormSchemaValidator';
import { VeoSchemaValidatorValidationResult } from '~/lib/ObjectSchemaValidator';
import { useVeoReactiveFormActions } from '~/composables/VeoReactiveFormActions';
import { useVeoErrorFormatter } from '~/composables/VeoErrorFormatter';

const GENERATOR_OPTIONS = (props: any) =>
  ({
    excludedProperties: [
      '/id$',
      '/type$',
      '/owner$',
      '^#/properties/links',
      '/updatedAt$',
      '/updatedBy$',
      '/createdAt$',
      '/createdBy$',
      '/parts$',
      '/members$',
      '/risks$',
      '/designator$',
      '/decisionResults',
      '(\\w+)/properties/domains$',
      '_self'
    ],
    groupedNamespaces: Object.keys(props.objectSchema.properties?.customAspects?.properties || {}).map((key) => ({
      namespace: `#/properties/customAspects/properties/${key}`,
      label: key
    })),
    generateControlFunction: generateFormSchemaControl,
    generateGroupFunction: generateFormSchemaGroup
  } as IVeoFormSchemaGeneratorOptions);

export default defineComponent({
  props: {
    /**
     * The value of the form
     */
    value: {
      type: Object as PropType<IBaseObject>,
      default: () => {}
    },
    /**
     * The object schema. Required. Creates the required inputs.
     */
    objectSchema: {
      type: Object as PropType<IVeoObjectSchema>,
      required: true
    },
    /**
     * The form schema. Rearranges the inputs generated by the object schema and adds additional labels.
     */
    formSchema: {
      type: Object as PropType<IVeoFormSchema>,
      default: undefined
    },
    /**
     * Meta data belonging to the form/object. Gets passed down for use by controls, layouts and widgets.
     */
    metaData: {
      type: Object as PropType<IBaseObject>,
      default: undefined
    },
    /**
     * Modifies the form and/or object schema at runtime.
     */
    additionalContext: {
      type: Object as PropType<IVeoFormsAdditionalContext>,
      default: undefined
    },
    /**
     * Get called after a value changes to update other data based on the changed data.
     */
    reactiveFormActions: {
      type: Object as PropType<IVeoFormsReactiveFormActions>,
      default: undefined
    },
    /**
     * Disables the complete form. If you only want to disable certain inputs, use the additional context.
     */
    disabled: {
      type: Boolean,
      default: false
    },
    /**
     * Disables creating new objects using the VeoCreateObjectDialog from within the form. Usually only set to true to avoid stacking VeoCreateObjectDialogs.
     */
    objectCreationDisabled: {
      type: Boolean,
      default: false
    },
    /**
     * Translations. VeoForms searches for all labels starting with #lang/... in this map.
     */
    translations: {
      type: Object as PropType<IVeoFormsTranslations>,
      default: () => {}
    },
    /**
     * If set to true, VeoForms will print a variety of data to the console in order to debug VeoForms.
     */
    debug: {
      type: Boolean,
      default: false
    }
  },
  emits: ['input', 'update:messages', 'update:valid'],
  setup(props, { emit }) {
    const { locale } = useI18n();

    const { defaultReactiveFormActions } = useVeoReactiveFormActions();
    const { formatErrors } = useVeoErrorFormatter();

    const localTranslations = computed(() => props.translations?.[locale.value] || {});
    const localAdditionalContext = computed(() => props.additionalContext || {});
    const localFormSchema = computed(() => props.formSchema || generateFormSchema(props.objectSchema, GENERATOR_OPTIONS(props), Mode.VEO));
    const localReactiveFormActions = computed(() => {
      const toReturn = defaultReactiveFormActions();

      for (const key in props.reactiveFormActions || {}) {
        if (toReturn[key]) {
          toReturn[key].push(...props.reactiveFormActions[key]);
        } else {
          toReturn[key] = props.reactiveFormActions[key];
        }
      }
      return toReturn;
    });

    // Form schema validation
    const formSchemaValidator = new FormSchemaValidator();
    const formSchemaFitsObjectSchema = computed<true | VeoSchemaValidatorValidationResult>(() => formSchemaValidator.validate(localFormSchema.value, props.objectSchema));

    // Object data validation
    const errorMessages = ref(new Map<string, string[]>());
    const validateFunction = computed(() => ajv.compile(props.objectSchema));

    // Form generation
    const defaultProps: IVeoFormElementDefaultProps = {
      metaData: props.metaData,
      disabled: props.disabled,
      objectCreationDisabled: props.objectCreationDisabled,
      translations: localTranslations.value,
      debug: props.debug
    };

    const createComponent = (element: any, formSchemaPointer: string): any => {
      const rule = evaluateRule(props.value, element.rule);

      element.options = merge(element.options || {}, rule);
      if (element.options.label && element.options.label.startsWith('#lang/')) {
        const key = element.options.label.split('/')[1];
        element.options.label = localTranslations.value[key] || key;
      }

      if (element.options.visible) {
        switch (element.type) {
          case 'Layout':
            return createLayout(element, formSchemaPointer);
          case 'Control':
            return createControl(element, formSchemaPointer);
          case 'Label':
            return createLabel(element, formSchemaPointer);
          case 'Widget':
            return createWidget(element, formSchemaPointer);
        }
      }
    };

    const createChildren = (element: IVeoFormElementFormSchema, formSchemaPointer: string) => {
      return element.elements && element.elements.map((elem, index) => createComponent(elem, `${formSchemaPointer}/elements/${index}`));
    };

    const createLayout = (element: IVeoFormElementFormSchema, formSchemaPointer: string) => {
      return h(
        VeoGroup,
        {
          props: {
            ...defaultProps,
            options: element.options,
            formSchemaPointer
          }
        },
        createChildren(element, formSchemaPointer)
      );
    };

    const createLabel = (element: IVeoFormLabelFormSchema, formSchemaPointer: string) => {
      return h(VeoLabel, {
        props: {
          ...defaultProps,
          options: element.options,
          formSchemaPointer,
          text: element.text
        }
      });
    };

    const createWidget = (element: IVeoFormWidgetFormSchema, formSchemaPointer: string) => {
      return h(Widget, {
        props: {
          ...defaultProps,
          options: element.options,
          formSchemaPointer,
          name: element.name,
          objectData: props.value
        }
      });
    };

    const createControl = (element: IVeoFormControlFormSchema, formSchemaPointer: string) => {
      if (!element.scope) {
        if (props.debug) {
          // eslint-disable-next-line no-console
          console.warn(`VeoForm::createControl: Control ${formSchemaPointer} has no scope: ${JSON.stringify(element)}`);
        }
        return;
      }

      // Special handling for link attributes, as they don't have a complete pointer in the form schema as they can only exist inside of their link
      if (element.scope.startsWith('#/properties/attributes')) {
        if (props.debug) {
          // eslint-disable-next-line no-console
          console.warn(`VeoForm::createControl: Custom Link attribute detected: ${element.scope}. Searching for custom link...`);
        }
        // Get object schema pointer of link based on the assumption that link attributes can't get displayed separately from the link
        const formSchemaPointerFragments = formSchemaPointer.split('/');
        const parentFormSchemaPointer = take(formSchemaPointerFragments, formSchemaPointerFragments.length - 2).join('/'); // Links can't be deconstructed, so the attributes are always direct children of the link
        const parentObjectSchemaPointer = (JsonPointer.get(localFormSchema.value, parentFormSchemaPointer) as IVeoFormControlFormSchema).scope;

        // Glue the object schema pointer of the link attribute to the one of the link to create a valid one for the whole object
        const objectSchemaPointerFragments = element.scope.split('/');
        element.scope = parentObjectSchemaPointer + '/items/' + takeRight(objectSchemaPointerFragments, objectSchemaPointerFragments.length - 1).join('/');
      }

      const controlObjectSchema = { ...(JsonPointer.get(props.objectSchema, element.scope) as JSONSchema7), ...(localAdditionalContext.value[element.scope]?.objectSchema || {}) };
      return h(Control, {
        props: {
          key: element.scope,
          ...defaultProps,
          options: { ...element.options, ...localAdditionalContext.value[element.scope]?.formSchema },
          formSchemaPointer,
          objectSchemaPointer: element.scope,
          objectSchema: addConditionalSchemaPropertiesToControlSchema(props.objectSchema, props.value, controlObjectSchema, element.scope),
          value: JsonPointer.get(props.value, removePropertiesKeywordFromPath(element.scope)),
          errors: errorMessages.value
        },
        on: {
          input: onControlInput
        },
        scopedSlots: {
          default: () => createChildren(element, formSchemaPointer)
        }
      });
    };

    // Input handling
    const onControlInput = (objectSchemaPointer: string, newValue: any, oldValue: string, index?: number) => {
      let valuePointer = removePropertiesKeywordFromPath(objectSchemaPointer);

      // If this condition is truthy, we have a link attribute and have to replace /items/ with the index.
      if (index !== undefined && valuePointer.includes('/items/')) {
        valuePointer = valuePointer.replace('/items/', `/${index}/`);
      }

      // Clone object to avoid mutating the original data
      let updatedForm = cloneDeep(props.value);

      // '' should be handled as if the value was deleted (an empty input field cleared with backspace returns '', while an input field cleared with the clear button returns undefined)
      if (newValue === '') {
        newValue = undefined;
      }

      // Set new value
      if (newValue === undefined) {
        JsonPointer.unset(updatedForm, valuePointer);
      } else {
        JsonPointer.set(updatedForm, valuePointer, newValue, true);
      }

      // Apply reactive form actions
      for (const action of localReactiveFormActions.value[objectSchemaPointer] || []) {
        updatedForm = action(newValue, oldValue, updatedForm, props.value);
      }

      // Validate new form data
      const formIsValid = validateFunction.value(updatedForm);
      if (!formIsValid) {
        errorMessages.value = formatErrors(validateFunction.value.errors as ErrorObject[], localTranslations.value);
      } else {
        errorMessages.value = new Map();
      }
      emit('update:messages', errorMessages.value);
      emit('update:valid', formIsValid);

      // Send updated form
      emit('input', updatedForm);
    };

    return () =>
      !formSchemaFitsObjectSchema.value
        ? h(VeoValidationResultList, { props: { items: (formSchemaFitsObjectSchema.value as VeoSchemaValidatorValidationResult).errors } })
        : h('div', { class: 'vf-wrapper' }, [createComponent(localFormSchema.value, '#')]);
  }
});
</script>
